# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1soIyYAFkDIRJFKF1EdfDOnk3w7N8E3SV
"""

import serial
import time
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#%% Iniciar controlador serie
def start():
  ser = serial.Serial(port='COM6', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=0.005, xonxoff=0, rtscts=0)
  ser.close() 
  ser.open()
  return ser

#reset controlador
def reset(ser):
  ser.write(bytes('X','utf-8')) 
  time.sleep(0.01)
  ser.flushInput()

#escribo voltaje, pregunto posicion y velocidad
def escribir_preguntar():
  str = 'V0\n\r'
  ser.write(bytes(str,'utf-8'))
  time.sleep(0.002)
  s = ser.readline(25)
  print(s)

#%% Defino funciones de comunicacion con el controlador

def setVoltageGetData(puerto,voltaje):
    puerto.flushInput()
    str = 'V%f\n\r' % (voltaje)
    puerto.write(bytes(str,'utf-8'))
    time.sleep(0.002)
    s = puerto.readline(25)
    pos = float(s[0:9])
    vel = float(s[10:23])  
    return pos,vel

def resetControlador(puerto):
    puerto.write(bytes('X','utf-8')) 
    time.sleep(0.01)
    puerto.flushInput()

def voltajeCorregido(voltaje):
    voltpos = 2
    voltneg = 2 
    maxvolt = 12
    if(voltaje > 0 ):        
        voltaje *= maxvolt/(maxvolt+voltpos)
        voltaje += voltpos
    else:        
        voltaje *= maxvolt/(maxvolt+voltneg)
        voltaje -= voltneg
    return voltaje

#%% Respuesta a un pulso de voltaje
def respuestaalpulso(volt):    
  resetControlador(ser) #reseteo el controlador
  time.sleep(0.2)

  #inicializo variables
  voltajes = np.concatenate((0*np.ones(10) ,volt*np.ones(80), 0*np.ones(10)))
  N = len(voltajes)
  posiciones = np.zeros(N)
  posiciones[:] = np.nan
  velocidades=np.zeros(N)
  velocidades[:] = np.nan
  tiempos=np.zeros(N)
  tiempos[:] =np.nan

  #loop poniendo voltaje y midiendo posicion y velocidad
  toc = time.time()
  for i in range(N):
    time.sleep(.04)
    pos,vel = setVoltageGetData(ser,voltajes[i]) 
    time.sleep(.04)
    posiciones[i] = pos
    velocidades[i] = vel
    tiempos[i] = time.time()-toc
  return[tiempos,voltajes,posiciones,velocidades]

Variables=respuestaalpulso(10)

#plot de la salida
plt.close('all')
fig, axs = plt.subplots(3, sharex=True)
axs[0].plot(tiempos, voltajes,'.-')
axs[0].set(ylabel = 'Voltaje')
axs[1].plot(tiempos, posiciones,'.-')
axs[1].set(ylabel = 'Posición')
v2 = np.diff(posiciones) / np.diff(tiempos) /256
axs[2].plot(tiempos[:-1], v2,'.-')
axs[2].plot(tiempos, velocidades,'.-')
axs[2].set(ylabel = 'Velocidad')
plt.legend(('Medida por la PC','Pedida por la placa'))
plt.xlabel('Tiempo [s]')

# Calcula el promedio de la volcidad para cada pulso de voltaje distinto. 
def muchos_pulsos(voltajes):
    vmedios=[]
    
    for voltaje in voltajes: 
        resultados = respuesta_pulso(voltaje)
        vel = resultados[3][30:80]
        prom = sum(vel)/len(vel)
        vmedios.append(prom)
    
    return vmedios

voltajes = np.linspace(-24,24,num=48,endpoint=False,retstep=False, dtype=None )
vmedios = muchos_pulsos(voltajes)
plt.plot(vmedios, voltajes,'.-')

#%%
"""------------------------ Caracterización del motor ------------------------"""
#Quiero calcular la pendiente entre la velocidad y el voltaje. 
"VAMOS HACER UN AJUSTE LINEAL!!!!"

def fit_func(x, m, b):
    return m*x + b

#Seleccionamos un conjunto de puntos donde el gráfico se ve lineal. 
v = voltajes[5:20]
ve = vmedios[5:20]

params = curve_fit(fit_func, v, ve)
[m,b] = params[0]

#%%
"""     Cálculo de la señal de control ( u(t) ) y  de los términos PID
        Proporcional = kp*e
        
        Integral = ki*integral(e)
        
        derivativo = kd*de/dt     """
        
def error(setpoint,variable):
    return (setpoint - variable)
        
def P(kp,error):
    return kp*error

def I(ki,error):
    return ki*error

def D(kd,error,error_prev,dt):
    return kd*(error - error_prev)/dt

def señal_control(P,I,D):
    return P+I+D


def Control_P(kp,setpoint):
  posicion = [] ; velocidad =[] ; tiempo = np.linspace(0,50,num=50)
  i=0 
  pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
  posicion.append(pos)
  velocidad.append(vel)
      
  e_0 = error(setpoint,pos) #Error Inicial.
  u = señal_control(P(kp,e_0), 0, 0)
          
  for t in tiempo:
      pos, vel = setVoltageGetData(ser, m*u)
      posicion.append(pos)
      velocidad.append(vel)
          
      e = error(setpoint, pos)
      u = señal_control(P(kp,e), 0, 0)
      
  plt.plot(tiempo, posicion,'--', label = f"Kp={kp}")
  plt.ylabel('Posición', size=15)
  plt.xlabel('Tiempo', size=15)
  plt.grid()
  plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
  plt.legend(loc=1)
  plt.show()


def control_PID(setpoint,L,R):
  posicion = [] ; velocidad =[] ; tiempo = np.linspace(0,50,num=50)
  kp=1.2/(L*R)
  ki=1.2/(2*R*L**2)
  kd=1.2/(2*R)
  dt =0.1

  #Primer paso
  pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
  posicion.append(pos)
  velocidad.append(vel)

  # Calculo error inicial. En este caso el error es +10.
  e_0 = error(setpoint,pos) 

  #Errores para en el termino integral.
  e_int_0 = 0 
  e_int = e_int_0 + e_0

  #Errores para el termino derivativo.
  e_prev_0 = 0 
  e_prev = e_prev_0 + e_0  

  u = señal_control(P(kp,e_0), 0 ,0)) #Saque el termino derivativo que estaba puesto, en el instante 0 no se puede derivar.


  for t in tiempo:
      pos, vel = setVoltageGetData(ser, m*u)
      posicion.append(pos)
      velocidad.append(vel)
      
      e = error(setpoint, pos)
      e_prev = e_prev + e
      e_int = e_int + e
      u = señal_control(P(kp,e),I(ki,e_int) , D(kd,e,e_prev,dt))

  plt.plot(tiempo, posicion, '--', c='tab:red')
  plt.ylabel('Posición', size=15)
  plt.xlabel('Tiempo', size=15)
  plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
  plt.legend()
  plt.show()

"""Posicion Vs Tiempo para distintos valores de Kp"""

posicion = [] ; velocidad =[] ; kp_lista=[0.1,0.3,0.5,0.8,1,3,10] ; tiempo = np.linspace(0,50,num=50)
setpoint = 10 
i=0 #Variable que voy a usar para crear gráficos.
for kp in kp_lista:
    #Primer paso
    pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
    posicion.append(pos)
    velocidad.append(vel)
    
    e_0 = error(setpoint,pos) #Error Inicial.
    u = señal_control(P(kp,e_0), 0, 0)
        
    for t in tiempo:
        pos, vel = setVoltageGetData(ser, m*u)
        posicion.append(pos)
        velocidad.append(vel)
        
        e = error(setpoint, pos)
        u = señal_control(P(kp,e), 0, 0)
    
    plt.plot(tiempo, posicion,'--', label = f"Kp={kp}")
    i=i+1
    time.sleep(0.02)

sns.lineplot()


plt.ylabel('Posición', size=15)
plt.xlabel('Tiempo', size=15)
plt.grid()
plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
plt.legend(loc=1)
plt.show()

#Hace lo mismo que control_P solo que le agrega el termino integral
"""Posicion Vs Tiempo para distintos valores de Ki"""

posicion = [] ; velocidad =[] ; ki_lista=[0.1,0.3,0.5,0.8,1,3,10]; tiempo = np.linspace(0,50,num=50)

kp=2 ; setpoint = 10 ; Ti= 1
i=0
for ki in ki_lista:
    #Primer paso
    pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
    posicion.append(pos)
    velocidad.append(vel)
    
    #Error inical. 
    e_0 = error(setpoint,pos) 
    
    #Errores para el termino integral.
    e_int_0 = 0 
    e_int = (e_int_0 + e_0)*Ti
    
    u = señal_control(P(kp,e_0), I(ki,e_int),0)
        
    for t in tiempo:
        pos, vel = setVoltageGetData(ser, m*u)
        posicion.append(pos)
        
        e = error(setpoint, pos)
        e_int = (e_int + e)*Ti
        u = señal_control(P(kp,e), I(ki,e_int), 0)

    plt.plot(tiempo, posicion,'--', label = f"Ki={ki}")
    i=i+1
    
plt.ylabel('Posición', size=15)
plt.xlabel('Tiempo', size=15)
plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
plt.legend(loc=1)
plt.show()

#Hace lo mismo que control_P solo que le agrega el termino derivativo

"""Posicion Vs Tiempo para distintos valores de Kd"""

posicion = [] ; velocidad =[] ; kd_lista=[0.1,0.3,0.5,0.8,1,3,10] ;tiempo = np.linspace(0,50,num=50)

kp=2 ; ki = 0 ; kd = 2 ; setpoint = 10 ; dt =1

for kd in kd_lista:
    #Primer paso
    pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
    posicion.append(pos)
    velocidad.append(vel)
    
    #Error incial.
    e_0 = error(setpoint,pos) 
    
    #Errores para el termino derivativo.
    e_prev_0 = 0 
    e_prev = e_prev_0 + e_0  
    
    u = señal_control(P(kp,e_0), 0 ,D(kd,e,e_0,dt))
    
    
    for t in tiempo:
        pos, vel = setVoltageGetData(ser, m*u)
        posicion.append(pos)
        velocidad.append(vel)
        
        e = error(setpoint, pos)
        e_prev = e_prev + e
        u = señal_control(P(kp,e),0 , D(kd,e,e_prev,dt))

plt.plot(tiempo, posicion, '--', c='tab:red')
plt.ylabel('Posición', size=15)
plt.xlabel('Tiempo', size=15)
plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
plt.legend()
plt.show()

posicion = [] ; velocidad =[] ; tiempo = np.linspace(0,50,num=50)

kp=2 ; ki = 2 ; kd = 2 ; setpoint = 10 ; dt =0.1

#Primer paso
pos, vel = setVoltageGetData(ser, 0) #Le mando 0 volts al motor. Entonces pos,vel=0
posicion.append(pos)
velocidad.append(vel)

# Calculo error inicial. En este caso el error es +10.
e_0 = error(setpoint,pos) 

#Errores para en el termino integral.
e_int_0 = 0 
e_int = e_int_0 + e_0

#Errores para el termino derivativo.
e_prev_0 = 0 
e_prev = e_prev_0 + e_0  

u = señal_control(P(kp,e_0), 0 ,D(kd,e,e_0,dt))


for t in tiempo:
    pos, vel = setVoltageGetData(ser, m*u)
    posicion.append(pos)
    velocidad.append(vel)
    
    e = error(setpoint, pos)
    e_prev = e_prev + e
    e_int = e_int + e
    u = señal_control(P(kp,e),I(ki,e_int) , D(kd,e,e_prev,dt))

plt.plot(tiempo, posicion, '--', c='tab:red')
plt.ylabel('Posición', size=15)
plt.xlabel('Tiempo', size=15)
plt.axhline(y=setpoint, linestyle=':', c='k', label='Setpoint')
plt.legend()
plt.show()

"""   ------------------------    Método Ziegler Nichols      ------------------------""" 
volt =  10
respuesta = respuestaalpulso(volt)

tiempo = respuesta[0]; posicion = [2]

def sigmoid (x, A, h, slope):
    return 1 / (1 + np.exp ((h - x) / slope)) *A

p, _ = curve_fit(sigmoid, tiempo, posicion)

A = p[0] ; xmedio = p[1] ;  slope = p[2] 
# Show parameters for the fit
# print(p)

L=xmedio
R=slope

#Escribo Kp, Ki, Kd
K_p=1.2/(L*R)
K_i=1.2/(2*R*L**2)
K_d=1.2/(2*R)

"""   ------------------------    Setpoint fijo      ------------------------""" 
setpoint = [100,300,1000,3000,10000]
kp=[0.1,10]
for sp in setpoint:
  for k in kp:
    control_p(k,sp)
    time.sleep(1)

"""   ------------------------    Setpoint lineal      ------------------------"""
vel=[10,100,1000,10000]
L= ; R=
for v in vel:
  tiempo=np.linspace(0,50,num=50)
  setpoint=v*tiempo
  control_PID(setpoint,L,R)

"""   ------------------------    Setpoint armonico      ------------------------"""
A=[100,1000,10000]
w=2*np.pi*[0.02,0.1,0.3,1,3]
L= ; R=
for a in A:
  for omega in w:
    tiempo=np.linspace(0,50,num=50)
    setpoint=A*np.sin(w*tiempo)
    control_PID(setpoint,L,R)